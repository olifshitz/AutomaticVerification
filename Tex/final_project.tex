\documentclass[11pt]{article}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{multicol}
\usepackage[noend]{algpseudocode}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

% TikZ Drawing packages

\usepackage{bbm}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{automata,positioning}


\textwidth=6in
\oddsidemargin=0.25in
\evensidemargin=0.25in
\topmargin=-0.1in
\footskip=0.8in
\parindent=0.0cm
\parskip=0.3cm
\textheight=8.00in
\setcounter{tocdepth} {3}
\setcounter{secnumdepth} {2}
\sloppy

\begin{document}

\setlength{\oddsidemargin}{.25in}
\setlength{\evensidemargin}{.25in}
\setlength{\textwidth}{6in}
\setlength{\topmargin}{-0.4in}
\setlength{\textheight}{8.5in}

\newcommand{\handout}[4]{
   \noindent
   \begin{center}
   \framebox{
      \vbox{
    \hbox to 5.78in { {\bf Automatic Verification of Systems} \hfill #1 }
       \vspace{4mm}
       \hbox to 5.78in { {\Large \hfill #4  \hfill} }
       \vspace{2mm}
       \hbox to 5.78in { {\it #2 \hfill #3} }
      }
   }
   \end{center}
   \vspace*{4mm}
}

\newcommand{\finalProjTitle}[4]{\handout{#1}{Lecturer:
#2}{Names: #3}{#4}}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{example}{Example}

\newcommand{\qed}{\rule{7pt}{7pt}}

\newenvironment{proof}{\noindent{\bf Proof:}\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-sketch}{\noindent{\bf Sketch of Proof:}\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-idea}{\noindent{\bf Proof Idea:}\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-of-lemma}[1]{\noindent{\bf Proof of Lemma #1:}\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-attempt}{\noindent{\bf Proof Attempt:}\hspace*{1em}}{\qed\bigskip}
\newenvironment{proofof}[1]{\noindent{\bf Proof}
of #1:\hspace*{1em}}{\qed\bigskip}
\newenvironment{remark}{\noindent{\bf Remark}\hspace*{1em}}{\bigskip}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\vspace{-2.0cm}\textbf{Automatic Verification of Systems \\ Final Project - 
Symbolic LTL Model Checking}}
\author{
	Omri Lifshitz \\
	\texttt{205490675} \\
	\texttt{omrilifshitz@mail.tau.ac.il}
	\and 
	Idan Berkovits \\
	\texttt{205404130} \\
	\texttt{berkovits@mail.tau.ac.il}
}
\date{}

\maketitle

%%Michal%% ==> Change the lecture number, lecture date, and Scribe name
%\finalProjTitle{September 3, 2018}{Dr. Sharon Shoham}{Omri Lifshitz, Idan Berkovits}
%{Symbolic LTL Model checking}

\section{Abstract}

\section{Introduction}

\section{CTL and LTL Model Checking}
    Let us begin by describing the temporal logic CTL*, and from there continue
    to describe both Computation Tree Logic (CTL) and Linear Temporal Logic(LTL).
    CTL* contains two types of formulae: state formulae which hold for specific
    states and path formulae which hold along a specific path. State formulae
    are given by the following rules \cite{ltl}:
    \begin{itemize}
        \item
            If $p \in AP$ (Atomic propositions) then $p$ is a state formula.

        \item
            If $f,\; g$ are state formulae then $\neg f, f \vee g$ are state formulae.

        \item
            If $f$ is a path formula, then $Ef$ ("for some computation path")
            is a state formula.
    \end{itemize}

    Path formulae are defined by the following rules:
    \begin{itemize}
        \item
            If $f$ is a state formula, it is also a path formula.

        \item
            If $f,\; g$ are path formulae then $\neg f,\; f \vee g, \; Xf$ and 
            $fUg$ are also path formulae.

        \item
            If $f$ is a path formula, then $Ef$ ("for some computation path")
            is a state formula.
    \end{itemize}
 
    Let $M = (S,R,L)$ be a Kripke structure where $S$ is the set of states, $R$
    is the transition relation (we assume there is a total transition relation)
    and $L$ be the labeling function.

    \begin{definition}
        A path in Kripke structure $M$ is an infinite sequence of states 
        $\pi = s_0,s_1,\dots$ such that for every $i\geq 0$, 
        $(s_i, s_{i+1})\in R$.
    \end{definition}

    The notation $M, s \models f$ is used to state that $f$ holds for state
    $s$ in the Kripke structure $M$, and similarly for $M, \pi \models f$ for
    path $\pi$ in $M$.

    \begin{definition}
        Let $f_1, f_2$ be state formulae and $g_1, g_2$ path formulae. 
        The relation $\models$ is defined recursively as follows:
        \begin{eqnarray}
            M,s \models p &\iff & p\in L(s) \\
            M,s \models \neg f_1 &\iff &M,s \not\models f_1 \\
            M,s \models f_1 \vee f_2 &\iff & M,s \models f_1 \text{or} M,s \models f_2 \\
            M,s \models Eg_1 &\iff &\text{there is a path $\pi$ starting at $s$ such
            that $M, \pi \models g_1$}\\
            M, \pi \models f_1 &\iff & s \text{ is the first state of $\pi$ and }
            M,s \models f_1 \\
            M, \pi \models \neg g_1 &\iff &M,\pi \not\models g_1\\
            M,\pi \models g_1 \vee g_2 &\iff & M,\pi \models g_1 \text{ or } M,\pi \models g_2 \\
            M, \pi \models Xg_1 &\iff &M,\pi^1 \models g_1\\
            M,\pi \models g_1Ug_2 &\iff &\exists k\geq 0\; s.t.\; M,\pi^k\models g_2\;
            \text{ and } \forall 0\leq j\leq k\; M,\pi^j \models g_1
        \end{eqnarray}
    \end{definition}

    \begin{definition}
        CTL is the subset of CTL* obtained by specifying the path formulae using
        the following rules\cite{ltl}:
        \begin{itemize}
            \item
                If $f,\;g$ are state formulae, then $Xf$ and $fUg$ are path
                formulae.
            \item
                If $f$ is a path formulae, then so is $\neg f$.
        \end{itemize}
    \end{definition}

    From the definition we can see that CTL is a subset of CTL* that only permits
    branching operators. Therefore, in this new logic, all linear-time operators
    can only appear if they are immediately preceded by path quantifiers.

    \begin{definition}
        LTL is a subset of CTL restricted to all formulae of the form $Af$ where
        $f$ is a path formula in which the only state sub-formulae are atomic
        propositions\cite{ltl}.
        More precisely, path formulae here are defined in the following recursive
        manner:
        \begin{itemize}
            \item
                An atomic proposition.
            \item
                If $f,\; g$ are path formulae, then $\neg f,\; f\vee g,\;
                Xf$ and $fUg$ are also path formulae.
        \end{itemize}
    \end{definition}


\section{Symbolic Model Checking - BDDs}

\section{Implementation}
    \subsection{Parsing formulae}
    \subsection{Creating the tableau}
    \subsection{Creating the product structure}
    \subsection{Finding Maximal SCC}
        As taught in class, in order to assert that there is a fair path in the 
        product structure, we need to find a strongly connected component (SCC)
        that is reachable from the initial state and that intersects with
        each one of the fairness constraints.
        
        In this section we will present the algorithm use to find the SCCs in
        a given model using BDDs. Our algorithm is based the algorithm explained
        in \cite{scc}.

        \begin{multicols}{2}
        \begin{algorithm}[H]
            \caption{SCC Decomposition}\label{scc}
            \Procedure{SCC\_Decomp}{N,V}
                \State $V' \gets V$

                \While {$V' \neq 0$}
                    \State $v \gets random\_take(V')$
                    \State $B(v) \gets backward_set(v, V', N)$
                    \State $SCC\_DECOMP\_RECUR(v, B(v), N)$
                    \State $V' \gets V' \wedge \overline{v \vee B(v)}$
                \EndWhile
            \EndProcedure
        \end{algorithm}

        \begin{algorithm}[H]
            \caption{Finite maximum distance predecessors}\label{fmd}
            \Procedure{FMD\_Pred}{W, U, N}
                \State $pred \gets 0$
                \State $front \gets W$
                \State $bound \gets U$
                
                \While{$front \neq 0$}
                    \State $x \gets \exists_Y front(Y)\wedge N(X, Y) \wedge bound(X)$
                    \State $y \gets \exists_Y bount(Y)\wedge N(X, Y) \wedge bound(X)$
                    \State $front \gets x \wedge \overline{y}$
                    \State $pred \gets pred \vee front$
                    \State $bount \gets bounts \wedge \overline{front}$
                \EndWhile

                \State \textbf{return} $pred$
            \EndProcedure
        \end{algorithm}

        \begin{algorithm}[H]
            \caption{Recursive method to find SCCs}\label{recursiveSCC}
            \Procedure{SCC\_Decomp\_Recur}{v, B(v), N}
                \State $F(v) \gets forward\_set(v, B(v), N)$
                \If{$F(v) \neq 0$}
                    \State \textbf{report} $F(v)$ an SCC
                \Else
                    \State \textbf{report} $v$ non- SCC
                \EndIf

                \State $x \gets F(v) \vee v$
                \State $R \gets B(v) \wedge \overline{x}$
                \State $y \gets \text{FMD\_PRED}(x, R, N)$
                \State \textbf{report} $y$ non-SCC
                \State $R \gets R \wedge \overline{y}$
                \State $IP \gets \exists_Y (y\vee x)(Y)\wedge N(X,Y) \wedge R(X)$
                
                \While{$R \neq 0$}
                    \State $v \gets random\_take(IP)$
                    \State $B(v) \gets backward_set(v, R, N)$
                    \State $SCC\_DECOMP\_RECURE(v, B(v), N)$
                    \State $R \gets R \wedge \overline{v \vee B(v)}$
                    \State $IP \gets IP \wedge \overline {v \vee B(v)}$

            \EndProcedure
        \end{algorithm}
        \end{multicols}

    \subsection{Finding fair paths}


\section{Experiments and Results}

\section{Further Work}


\pagebreak
\bibliographystyle{plain}
\bibliography{final_project}

\end{document}
