\documentclass[11pt]{article}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{multicol}
\usepackage[noend]{algpseudocode}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

% TikZ Drawing packages

\usepackage{bbm}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{automata,positioning}


\textwidth=6in
\oddsidemargin=0.25in
\evensidemargin=0.25in
\topmargin=-0.1in
\footskip=0.8in
\parindent=0.0cm
\parskip=0.3cm
\textheight=8.00in
\setcounter{tocdepth} {3}
\setcounter{secnumdepth} {2}
\sloppy

\begin{document}

\setlength{\oddsidemargin}{.25in}
\setlength{\evensidemargin}{.25in}
\setlength{\textwidth}{6in}
\setlength{\topmargin}{-0.4in}
\setlength{\textheight}{8.5in}

\newcommand{\handout}[4]{
   \noindent
   \begin{center}
   \framebox{
      \vbox{
    \hbox to 5.78in { {\bf Automatic Verification of Systems} \hfill #1 }
       \vspace{4mm}
       \hbox to 5.78in { {\Large \hfill #4  \hfill} }
       \vspace{2mm}
       \hbox to 5.78in { {\it #2 \hfill #3} }
      }
   }
   \end{center}
   \vspace*{4mm}
}

\newcommand{\finalProjTitle}[4]{\handout{#1}{Lecturer:
#2}{Names: #3}{#4}}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{example}{Example}

\newcommand{\qed}{\rule{7pt}{7pt}}

\newenvironment{proof}{\noindent{\bf Proof:}\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-sketch}{\noindent{\bf Sketch of Proof:}\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-idea}{\noindent{\bf Proof Idea:}\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-of-lemma}[1]{\noindent{\bf Proof of Lemma #1:}\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-attempt}{\noindent{\bf Proof Attempt:}\hspace*{1em}}{\qed\bigskip}
\newenvironment{proofof}[1]{\noindent{\bf Proof}
of #1:\hspace*{1em}}{\qed\bigskip}
\newenvironment{remark}{\noindent{\bf Remark}\hspace*{1em}}{\bigskip}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%Michal%% ==> Change the lecture number, lecture date, and Scribe name
\finalProjTitle{September 3, 2018}{Dr. Sharon Shoham}{Omri Lifshitz, Idan Berkovits}
{Symbolic Model checking}

\section{Abstract}

\section{Introduction}

\section{CTL and LTL Model Checking}

\section{Symbolic Model Checking - BDDs}

\section{Algorithm}
    \subsection{Finding Maximal SCC}
        As taught in class, in order to assert that there is a fair path in the 
        product structure, we need to find a strongly connected component (SCC)
        that is reachable from the initial state and that intersects with
        each one of the fairness constraints.
        
        In this section we will present the algorithm use to find the SCCs in
        a given model using BDDs. Our algorithm is based the algorithm explained
        in \cite{scc}.

        \begin{algorithm}
            \caption{SCC Decomposition}\label{scc}
            \Procedure{SCC\_Decomp}{N,V}
                \State $V' \gets V$

                \While {$V' \neq 0$}
                    \State $v \gets random\_take(V')$
                    \State $B(v) \gets backward_set(v, V', N)$
                    \State $SCC\_DECOMP\_RECUR(v, B(v), N)$
                    \State $V' \gets V' \wedge \overline{v \vee B(v)}$
                \EndWhile
            \EndProcedure
        \end{algorithm}

        \begin{algorithm}
            \caption{Finite maximum distance predecessors}\label{fmd}
            \Procedure{FMD\_Pred}{W, U, N}
                \State $pred \gets 0$
                \State $front \gets W$
                \State $bound \gets U$
                
                \While{$front \neq 0$}
                    \State $x \gets \exists_Y front(Y)\wedge N(X, Y) \wedge bound(X)$
                    \State $y \gets \exists_Y bount(Y)\wedge N(X, Y) \wedge bound(X)$
                    \State $front \gets x \wedge \overline{y}$
                    \State $pred \gets pred \vee front$
                    \State $bount \gets bounts \wedge \overline{front}$
                \EndWhile

                \State \textbf{return} $pred$
            \EndProcedure
        \end{algorithm}

        \begin{algorithm}
            \caption{Recursive method to find SCCs}\label{recursiveSCC}
            \Procedure{SCC\_Decomp\_Recur}{v, B(v), N}
                \State $F(v) \gets forward\_set(v, B(v), N)$
                \If{$F(v) \neq 0$}
                    \State \textbf{report} $F(v)$ an SCC
                \Else
                    \State \textbf{report} $v$ non- SCC
                \EndIf

                \State $x \gets F(v) \vee v$
                \State $R \gets B(v) \wedge \overline{x}$
                \State $y \gets \text{FMD\_PRED}(x, R, N)$
                \State \textbf{report} $y$ non-SCC
                \State $R \gets R \wedge \overline{y}$
                \State $IP \gets \exists_Y (y\vee x)(Y)\wedge N(X,Y) \wedge R(X)$
                
                \While{$R \neq 0$}
                    \State $v \gets random\_take(IP)$
                    \State $B(v) \gets backward_set(v, R, N)$
                    \State $SCC\_DECOMP\_RECURE(v, B(v), N)$
                    \State $R \gets R \wedge \overline{v \vee B(v)}$
                    \State $IP \gets IP \wedge \overline {v \vee B(v)}$

            \EndProcedure
        \end{algorithm}



\section{Implementation}

\section{Experiments and Results}

\section{Further Work}


\pagebreak
\bibliographystyle{plain}
\bibliography{final_project}

\end{document}
